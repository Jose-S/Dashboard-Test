/// <reference types="node" />
import { ExecOptions, ExecSyncOptions, SpawnOptions } from 'child_process';
import { PackageManagers } from './api';
/**
 * Provides an async check for if we are equipped to use `yarn` for package management operations.
 * @internal
 */
export declare const shouldUseYarn: () => Promise<boolean>;
/**
 * Provides an async check for if we are equipped to use `npm` in the current root as fallback for package management
 * operations.
 *
 * @see {@link https://bit.ly/2rEVJtD}.
 * @ignore
 */
export declare const canUseNpm: (root: string) => Promise<boolean>;
/**
 * Abstraction around the logic to manage node package-manager related tasks such as installing, removing packages, etc.
 */
export declare class PackageManager {
    readonly binary: PackageManagers;
    constructor(binary: PackageManagers);
    get commands(): {
        [key: string]: string;
    };
    /**
     * Adds a new dependency to a project.
     */
    addDependency(packages: string, options?: SpawnOptions): Promise<unknown>;
    /**
     * Installs all the dependencies listed in package.json.
     */
    installAllDependencies(options?: ExecOptions): Promise<unknown>;
    /**
     * Executes a custom command with the current package manager.
     */
    exec(args: string[], options?: SpawnOptions): Promise<unknown>;
    execBinary(command: string, options?: ExecSyncOptions): void;
}
/**
 * Returns a cached package manager instance with the binary set according depending on the availability of npm/yarn.
 */
export declare const getPackageManager: () => Promise<PackageManager>;
//# sourceMappingURL=package-manager.d.ts.map