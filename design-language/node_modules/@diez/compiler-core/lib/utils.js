"use strict";var e=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var r={};if(null!=e)for(var t in e)Object.hasOwnProperty.call(e,t)&&(r[t]=e[t]);return r.default=e,r};Object.defineProperty(exports,"__esModule",{value:!0});const r=require("@diez/cli-core"),t=require("change-case"),o=require("fs-extra"),n=require("path"),s=require("source-map"),i=require("ts-morph"),a=require("typescript");exports.isConstructible=(e=>void 0!==e.prototype&&e.prototype.constructor instanceof Function),exports.getProjectRoot=(async()=>{const e=(await r.findPlugins()).get("."),t=e&&e.projectRoot;return n.resolve(t||global.process.cwd())}),exports.projectCache=new Map,exports.getProject=(e=>{if(exports.projectCache.has(e))return exports.projectCache.get(e);const r=a.findConfigFile(e,a.sys.fileExists,"tsconfig.json");if(!r)throw new Error("Unable to proceed: TypeScript configuration not found.");const t=new i.Project({tsConfigFilePath:r});return t.compilerOptions.set({skipLibCheck:!0,suppressOutputPathCheck:!0,noEmitOnError:!0,sourceMap:!0}),exports.projectCache.set(e,t),t});const c=new Map;exports.getTargets=(async()=>{if(c.size>0)return c;for(const[e,{providers:t}]of await r.findPlugins())if(t&&t.targets)for(const o of t.targets){const t=r.cliRequire(e,o),n=t.name.toLowerCase();if(c.has(n))throw new Error(`A target named ${n} is already registered.`);c.set(n,t)}return c});const u=(e,r,t)=>`${e}|${((e,r)=>`${e}:${r}`)(r,t)}`,p=new Map,g=new Map;exports.getBinding=(async(e,t,o)=>{const s=u(e,t,o);if(g.has(s))return g.get(s);const i=await(async(e,t,o)=>{const s=u(e,t,o);if(p.size>0)return p.get(s);for(const[e,{bindings:t}]of await r.findPlugins())if(t)for(const o in t)for(const s in t[o]){const i=`${s}|${o}`;p.has(i)?r.Log.warning(`Found duplicate binding compilation instructions for target ${s}. Component: ${o}. Only the first binding will be used.`):p.set(i,n.join("."===e?global.process.cwd():e,t[o][s]))}return p.get(s)})(e,t,o);if(i)try{const e=require(i);return g.set(s,e),e}catch(e){return r.Log.warning(`A binding for ${o} was specified, but could not be loaded from ${i}.`),void g.set(s,void 0)}else g.set(s,void 0)}),exports.getAssemblerFactory=(async e=>{for(const[t,{providers:o}]of await r.findPlugins())if(o&&o.assemblers&&o.assemblers&&o.assemblers[e])return r.cliRequire(t,o.assemblers[e]);throw new Error(`Unable to find assembler for target: ${e}`)}),exports.printWarnings=(e=>{for(const[t,o]of e)o.warnings.ambiguousTypes.size&&(r.Log.warning(`Component: ${t}`),r.Log.warning("  The following properties are of an unknown or invalid type. Please ensure your component definition includes complete type annotations."),o.warnings.ambiguousTypes.forEach(e=>r.Log.warning(`  - ${e}`)))}),exports.getHotPort=(async()=>r.findOpenPort(r.getCandidatePortRange(8080,100))),exports.loadComponentModule=(async r=>await Promise.resolve().then(()=>e(require(r)))),exports.purgeRequireCache=((e,r)=>{const t=r||n.dirname(e);if(require.cache[e]){for(const r of require.cache[e].children)r.id.startsWith(t)&&exports.purgeRequireCache(r.id);delete require.cache[e]}}),exports.inferProjectName=(e=>{try{return t.noCase(require(n.join(e,"package.json")).name,void 0,"-")}catch(e){return"design-language"}}),exports.inferProjectVersion=(e=>{try{return require(n.join(e,"package.json")).version}catch(e){return"0.1.0"}}),exports.isAcceptableType=(e=>void 0!==e&&(i.TypeGuards.isClassDeclaration(e)||i.TypeGuards.isObjectLiteralExpression(e)));exports.getDescriptionForValue=(e=>{const r=i.TypeGuards.isClassDeclaration(e)||i.TypeGuards.isPropertyDeclaration(e)?e:e.getParent();if(!r||!i.TypeGuards.isJSDocableNode(r))return(e=>{if(e){let r=e;if(i.TypeGuards.isObjectLiteralExpression(e)){const t=e.getParent();if(t){const e=t.getParent();if(e){const t=e.getParent();t&&(r=t)}}}const t=r.getFirstChild();if(t&&i.TypeGuards.isJSDoc(t))return{body:t.getComment()||""}}return{body:""}})(e);const t=[];for(const e of r.getJsDocs()){const r=e.getComment();void 0!==r&&t.push(r)}return{body:t.join("\n")}});exports.ExistingHotUrlMutexError=class extends Error{constructor(e,r){super(e),this.name="ExistingHotUrlMutexError",this.message=e,this.mutexPath=r}},exports.showStackTracesFromRuntimeError=(async e=>{if(void 0===e.stack)return void r.Log.error(e.message);const t=e.stack.split("\n")[1];if(!t)return void r.Log.error(e.toString());const i=t.match(/\(([^\)]+)\)/);if(!i)return void r.Log.error(e.toString());const[a,c,u]=i[1].split(":");if(a&&c&&u)try{const t=await o.readFile(`${a}.map`),i=(await new s.SourceMapConsumer(t.toString())).originalPositionFor({line:Number(c),column:Number(u)}),p=n.resolve(a,"..",i.source||"");if(r.Log.error(e.message),r.Log.error(`    at ${p}:${i.line}:${i.column}`),i.line){const e=(await o.readFile(p)).toString().split("\n")[i.line-1];let t="";i.column&&(t=`${" ".repeat(i.column-1||0)}^`),r.Log.code(`${e}\n${t}`)}}catch(t){r.Log.error(e.toString())}else r.Log.error(e.toString())});
//# sourceMappingURL=/@diez/compiler-core/lib/utils.js.map